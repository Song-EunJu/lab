## 2장 : 이상한 나라의 객체

- 인간은 본능적으로 세상을 독립적이고, 식별 가능한 객체의 집합으로 바라봄
  - 객체지향이 세상을 자율적이고 독립적인 객체들로 분해할 수 있는 인간의 기본적 인지능력에 기반을 두고 있기 때문에 이해하기 쉬운 패러다임이라고 함
  - 하지만, 객체지향 패러다임의 목적은 현실 세계 모방하는 것 X 
    - 현실 세계를 기반으로 **새로운 세계 창조하는 것**<br>
     ex) 현실의 전등은 스스로 불을 킬 수 없지만, SW 세계에서는 스스로 전원 onoff 가능

<br>

- 앨리스의 키라는 `상태`를 결정하는 요인 : 앨리스가 물을 마셨다는 `행동`<br>
  하지만, 키가 커졌다는 `행동의 결과` 를 결정하는 것은 키라는 `상태`<br>
  → 결국, 물을 마시기 전 앨리스 키가 얼마였느냐가, 물을 마신 후의 앨리스 키를 결정함<br>
  → **행동의 결과는** **상태에 의존적**
<br>

- 객체 : **변경가능한** 상태 + **특징적인** 행동 + **구별가능한** 식별자를 지닌 실체
---
1. 상태
    - **특정시점에** `객체가 가진 정보의 집합`으로 객체의 특징을 표현하는 것
    - **프로퍼티** : 객체의 상태를 구성하는 모든 특징<br>
      - 단순한 값(속성)  ex) 키, 위치
      - 객체의 조합(링크)  ex) 음료  
  
        ![][def]
        
        > 여기서 코드로는 어떻게 표현할 수 있을까 고민해보았다.

        ```java
        class Elice {
            int height;
            int position;
            Drink drink; // 결국 이게 has-a 관계인 것 같다
        }
        
        class Drink {
            int amount;
        }
        ```
        - 의문점 : 음료 양이 변하는 게 앨리스의 상태가 변하는 걸까?
          - 음료양에 따라 앨리스의 키가 변동되면 상태가 변하는 것이지만, 그게 아니면 음료 객체의 상태만 변하는 것<br>

   - 객체는 다른 객체의 상태에 직접적 접근 불가, 상태 변경 불가
     - 따라서, 간접적으로 객체의 상태를 변경하거나 조회할 수 있는 방법이 필요<br>
    → 이 때 행동이 등장. 
2. 행동
   - 외부의 요청 또는 수신된 메시지에 **응답**하기 위해 동작하고 반응하는 것
   - 행동으로 인해 발생할 수 있는 결과
     - **객체 자신의 상태 변경**
     - 행동 내에서 협력하는 **다른 객체에 대한 메시지 전송**<br>
  ex) 앨리스가 음료를 마시면 / 앨리스의 상태뿐만 아니라, 음료의 양도 줄어든다.<br>
    즉, 앨리스 자기자신의 상태 변경 뿐만 아니라, 음료의 상태변경도 유발

    - 유의할 점
      - 모든 객체는 자신의 상태를 스스로 관리하는 `자율적` 존재
      - 음료 객체의 양을 줄이는 것은 음료 자신이어야 함. 앨리스는 관여할 수 없음
      
    ![][def2]
      - 메시지 송신자는 메시지 **수신자의 상태변경에 대해서는 전혀 알지 못한다**<br>
      → 캡슐화 (외부에 노출하는 것 == 외부에서 객체에 접근할 수 있는 유일한 방법은 행동 뿐)

3. 식별자
    - 객체를 다른 객체와 구분하는 데 사용하는 객체의 프로퍼티
    - **`동등성`** : `상태`를 이용해 **두 값이 같은지** 판단할 수 있는 성질<br>
    → 상태를 이용해서 동등성을 판단할 수 있는 이유는 **값의 상태 ( = 정적인 프로퍼티) 가 변하지 않기 때문**<br>
    ex) int num = 10; int num = 10;

        ```java
        class Elice {
            int height = 170; // height : 정적인 프로퍼티, 170 : 동적인 프로퍼티
            Water water;
        }

        class Elice {
            int height = 180;
            Water water;
        }
        // 이름, 키 등의 상태 (정적프로퍼티) 는 동일하지만, 두 사람은 별개의 인격체
        ```

   - **`동일성`** : `식별자`를 기반으로 **객체가 같은지**를 판단할 수 있는 성질<br>
    → 상태를 이용해서 동일성을 판단할 수 있는 이유는 **객체의 상태가 변하기 때문**

---


❌ 상태를 먼저 결정하고 행동을 나중에 결정하는 것은 나쁜 설계 방식

- 객체 지향 설계 수행 순서
  
  1. 필요한 협력을 생각
  2. 협력에 참여하는 데 필요한 행동 생각
  3. 행동을 수행할 객체 선택 

- 협력 안에서 객체의 `행동` == 협력에 참여하면서 객체가 완수해야 하는 `책임`

✅ 행동이 상태를 결정한다<br>

- 현실 속의 수동적 존재가 SW 객체로 구현될 때는 능동적으로 변화됨<br>
→ 의인화 : 현실의 객체보다 더 많은 일을 할 수 있는 SW 객체의 특징
- 현실 속의 객체 의미 일부가 SW 객체로 전달되기 때문에, 프로그램 내의 객체는 현실 속 객체에 대한 은유


[def]: https://velog.velcdn.com/images%2Fcode12%2Fpost%2F84718c24-a20c-4581-8525-9f0f2a39f4cc%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-09-29%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.12.13.png
[def2]: https://velog.velcdn.com/images/hye_b/post/60c3fcbe-f7b7-45b3-954b-d2ac1049df8e/image.png
