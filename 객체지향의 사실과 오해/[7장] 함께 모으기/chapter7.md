## 7장 : 함께 모으기

- 객체지향 설계 안에 존재하는 3가지 상호 연관된 관점
    - 개념
        - 설계는 도메인 (유저들이 관심을 가지고 있는 특정 분야나 주제) 안에 존재하는 개념과 개념들 사이의 관계
        - **사용자가 도메인을 바라보는 관점**을 반영 == 실제 도메인의 규칙/제약을 최대한 유사하게 반영
    - 명세
        - 사용자의 영역인 도메인을 벗어나, 개발자의 영역인 소프트웨어에 초점
        - 소프트웨어 내에 살아 숨쉬는 객체들의 책임에 초점을 맞춤 == 객체가 협력을 위해 **무엇을** 할 수 있는가 (객체의 인터페이스를 바라봄)
    - 구현
        - 객체들이 책임을 수행하는 데 필요한, 동작하는 코드 작성 == 책임을 **어떻게** 수행할 것인가 (객체의 인터페이스를 구현하는데 필요한 속성/메소드를 클래스에 추가)

- 클래스 → 도메인 관점 반영
클래스의 공용 인터페이스 → 명세 관점 반영
클래스의 속성/메소드 → 구현 관점 반영

---

- 동적인 객체를 정적인 타입으로 추상화해서 복잡성을 낮출 수 있음<br>
→ 상태와 무관하게, **동일하게 행동할 수 있는 객체는 동일한 타입의 인스턴스로 분류 가능**
    - 어떤 타입이 도메인을 구성하느냐 + 타입들 사이에 어떤 관계가 존재하는지 파악하여 도메인을 이해하자

---

객체지향 설계의 목표는 훌륭한 객체 설계 X / 훌륭한 협력 설계 O

- 협력 설계 시, 객체가 메시지를 선택 X / 메시지가 객체 선택 O
    - 메시지를 먼저 선택하고      |   “커피를 주문하라”
    - 메시지를 수신하기에 적절한 객체 선택       |  “손님”
    - 메시지 수신한 객체는 메시지를 처리할 책임을 맡음     |  “손님” 이 커피를 주문할 책임을 가지고 있는 것
    - 객체가 수신하는 메시지는 객체가 외부에 제공하는 공용 인터페이스에 포함됨       |    “커피를 주문하다” 를 표현하는 order 메소드가 공용 인터페이스가 됨

- **메시지를 수신한 쪽**이, **메시지를 처리하게 되는 객체**가 됨 
== 메시지를 처리할 책임이 할당된 것
- 자신이 스스로 할 수 없는 일이라면, 새로운 메시지를 만들어 내어 다른 객체에게 제공해줄 것을 요구함 (메시지 송신)

ex) “커피를 주문하라” 라는 메시지를 수신한 객체는 “손님” 이고, “손님” 이 커피를 주문할 책임을 가지고 있는 것이다

ex) 메뉴 항목을 가장 잘 알고 있기 때문에 “메뉴 항목을 찾아라” 라는 메시지를 수신한 객체는 “메뉴판” 이고, “메뉴판” 이 생명력을 가진 존재처럼 스스로 메뉴 항목을 찾는다

→ 소프트웨어 세계에서는 무생물을 생물처럼 `의인화` 해야 한다

--- 

### 인터페이스 정리하기

- 메시지가 객체를 선택했고, 선택된 객체는 메시지를 자신의 인터페이스로 받아들임
    - “커피를 주문하라” 라는 메시지가 “손님” 이라는 객체를 선택했고, “손님” 객체는 “커피를 주문하라” 를 인터페이스로 받아들임
- 객체들을 협력이라는 문맥에서 떼어냈을 때, **수신 가능한 메시지 == 객체의 인터페이스**
    - 객체의 인터페이스 안에 메시지에 해당하는 오퍼레이션이 존재<br>
        → 따라서 “손님” 객체의 인터페이스 안에는 “커피를 주문하라” 라는 오퍼레이션이 포함됨
- 객체들의 협력은 런타임의 동작을 동적으로 묘사한 모델이지만, 실제 소프트웨어 구현은 **동적 객체가 아닌 정적 타입**으로 이뤄진다
    - 객체들을 포괄하는 타입 정의 → 식별된 오퍼레이션을 타입의 인터페이스에 추가 (이는 외부에서 접근 가능한 public 공용 인터페이스의 일부)
- 객체가 다른 객체에게 메시지를 전송하기 위해서는 먼저 `객체에 대한 참조` 를 얻어야 함
<br>                                                                                                                                                                                                                                                                 

### 객체 구현 세부사항을 객체 공용 인터페이스에 노출시키지 않고, 인터페이스와 구현을 깔끔하게 분리할 수 있는 방법
- 객체의 속성은 객체 내부 구현에 속하므로 캡슐화 되어야 함<br>
→ 인터페이스에는 객체 내부 속성에 대한 어떤 힌트도 제공돼서는 안됨<br>
→ 이를 위해서, 인터페이스 정하는 단계에서 **객체가 어떤 속성을 갖고, 그 속성이 어떤 자료구조인지 고려하지 말자
( 가급적 객체 내부의 구현에 대한 어떤 가정도 하지 않음 )**

<br>

[참고] 
- 인터페이스를 통해 실제로 상호작용해보지 않은 채 인터페이스의 모습을 정확히 예측하는 것은 거의 불가능
- 따라서 설계를 간단히 끝내고 최대한 빨리 구현에 돌입하자
    - 테스트-주도 설계로 코드를 구현하는 사람들은, 테스트코드를 작성해가면서 협력을 설계함

---

### 코드는 3가지 관점을 모두 제공해야 한다

- 객체지향 설계 안에 존재하는 3가지 상호 연관된 관점
- **개념** : 커피 전문점 도메인을 구성하는 중요 개념과 관계를 반영함
    - 소프트웨어 클래스가 도메인 개념의 특성을 최대한 수용하면, 변경 관리 쉽고 유지보수성 향상
- **명세** : 구현과 관련된 세부사항이 드러나지 않도록 안정적인 인터페이스 설계
- **구현** : 메소드와 속성은 공용 인터페이스의 일부가 아니므로, 이들의 변경이 원칙적으로 외부 객체에 영향을 미쳐서는 안됨

- 메시지를 수신할 객체를 선택하는 방법 : **도메인 개념 중에 가장 적절한 것을 선택하기**
- 명세 관점 (인터페이스) 가 설계를 주도하면, 설계의 품질이 향상될 수 있음
